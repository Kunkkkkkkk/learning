即一个队列绑定了多个消费者（consumer），同一个消息只会被一个消费者监听到

比如有50条消息，2个消费者。A消费者得到的全是单数，另一个消费者得到的全是双数。

即使我们给他们用Theard.sleep()设置不同的延迟，会发现监听到的消息不变，各25个。

在现实生活里各个消费者的机器性能不一样，所以可能会出现性能强的consumer都已经监听完了性能弱的还没结束，导致消息堆积。

这时候可以

```
spring:
	rabbitmq:
		listener:
			simple:
				prefetch: 1   每次只获取一条消息，处理完后才能下一个
```

然后用上面的案例来测试，发现延迟小的consumer比另一个处理了更多的消息。