

```java
public class 反射 {
    public static void main(String[] args) throws Exception{
        Student student = new Student();
        //类加载的时候会有一个字节码对象被放到堆内存里面。想用反射机制必须得先拿到这个对象，一个类的字节码对象，有且只有一个
        /** 拿到字节码对象的方法
         * 1.直接用实例对象.getClass();
         * 2.用Class.forName(完整类带包名)
         * 3.类字面常量.class
         * */
        Class<?> aClass1 = student.getClass();
        Class<?> aClass2 = Student.class;
        Class<?> aClass3 = Class.forName("com.lyk.Student");
        System.out.println(String.valueOf(aClass1==aClass2));
        System.out.println(String.valueOf(aClass1==aClass3));
        System.out.println(String.valueOf(aClass2==aClass3));
        System.out.println("----------------------------------");
        //拿到构造方法类
        /**
         * public构造方法  Constructor<?>[] getConstructors()
         * 所有构造方法（包括private）    Constructor<?>[] getDeclaredConstructors()
         * 指定的public构造方法 Constructor getConstructor(Class<?>... parameterTypes)  这个里面填的就是参数类型
         * 指定的构造方法（包括private）    Constructor getDeclaredConstructor(Class<? >... parameterTypes)
         * */
        Constructor<?>[] constructors = aClass1.getConstructors();
        for (Constructor<?> constructor : constructors) {
            System.out.println(constructor);
        }
        Constructor<?> constructors1 = aClass2.getConstructor(String.class,int.class);
        Constructor<?> constructors2 = aClass3.getDeclaredConstructor(String.class);
        System.out.println(constructors1);
        System.out.println("----------------------------------");

        //用拿到的构造方法来创建对象
        /**（T） newInstance(Object...initargs) 这里面是放参数的，不放就是无参
         * setAccessible(boolean flag)  这里是对字节码对象（即那个类）使用而不是实例对象
         * 它的主要作用是绕过 Java 的访问控制检查，从而允许对类的私有成员（字段、方法、构造方法等）进行访问。
         * */
        Student student1 = (Student)constructors1.newInstance("wangjia",18);
        System.out.println(student1.getName());
        //设置了之后就可以访问私有的构造器 就是获取到私有的不能直接使用，必须先这样给权限
        constructors2.setAccessible(true);
        Student student2 = (Student)constructors2.newInstance("jiawang");
        System.out.println(student2.getName());

        //获取到类里面的成员变量
        /**Field[] getFields()
         * Field[] getDeclaredFields() 可以私有但是不包括继承的
         * Field getField(String name)
         * Field getDeclaredFiled(String name)  可以私有但是不包括继承的
         * 也要setAccessible(boolean flag)设置访问权限
         * */

        Field field = aClass1.getField("alive");
        System.out.println(field);
        //用field来给对象赋值和获取
        /**
         *(Object) get(一个对象) ，注意这里get到的是一个object类型，得强转
         * set(目标对象,数据)
         * */
        Student student3=new Student();
        student3.setAlive(true);
        boolean alive000=(Boolean) field.get(student3);
        System.out.println(student3.alive);
        field.set(student3,false);
        System.out.println(student3.alive);

        //使用成员方法
        /**
         * 获取方法
         * Method[] getMethods() 返回所有公共成员方法对象的 数组(包含继承的)
         * Method getMethod(String name, Class<?>... parameterTypes)
         * 返回单个公共成员方法对象(包 含继承的)
         * Method[] getDeclaredMethods() 返回所有成员方法对象的数组 (含private，不含继承)
         * Method getDeclaredMethod(String name, Class<?>... parameterTypes)
         * 返回单个成员方法对象(含 private，不含继承)
         * 使用方法
         * invoke
         * (返回值，没有就不写)方法对象.invoke(实例对象,参数（没有就不写）)
         * 所有的这些使用private都要开放权限
         * */
        Method method = aClass1.getMethod("setName",String.class);
        System.out.println("student1原来的name是"+student1.getName());
        method.invoke(student1,"wangjiadashagua");
        System.out.println("student1现在的name是"+student1.getName());
        List<Integer> list =new ArrayList<>();
        
        /**
         * 通过反射将 String 或其他非 Integer 类型的对象插入到一个 List<Integer> 中是可能的，这是因为 Java 泛型在运行时使用的是类型擦除（Type Erasure）机制。
         *
         * 类型擦除机制
         * 在 Java 中，泛型是一个编译时的特性，它在编译时会进行类型检查以确保类型安全，但在编译后，所有的泛型类型信息都会被擦除。这意味着在运行时，List<Integer> 和 List<String> 实际上都只是一个 List，并没有任何具体的类型信息。这种类型擦除使得泛型在运行时无法强制约束类型一致性。
         *
         * 反射的作用
         * 由于类型擦除，反射在运行时并不会知道 List<Integer> 的元素必须是 Integer 类型。使用反射操作时，你可以绕过编译时的类型检查，并将不符合泛型限制的对象插入到列表中。*/
        //List里面直接add的那个方法是boolean add (E e)
    }

}

class Student extends People{
    private String name;
    private int age;

    private void play(){
        System.out.println("学生打游戏");
    }
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public Student(){}

    private Student(String name){
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

class People{
    private String name;
    private int age;
    public boolean alive;
    private void eat(){
        System.out.println("人吃饭");
    }
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public boolean isAlive() {
        return alive;
    }

    public void setAlive(boolean alive) {
        this.alive = alive;
    }
}

```

例子，反射拿到注解的value

```java
 //1.先拿到这个类
        Object target = joinPoint.getTarget();
        //2.拿到方法参数类型和方法名
        String MethodName = joinPoint.getSignature().getName();
        Class<?>[] ParamterType = ((MethodSignature)joinPoint.getSignature()).getParameterTypes();
        //3.根据方法参数类型和方法名拿到这个方法
        Method method =target.getClass().getMethod(MethodName,ParamterType);
        //4.判断这个方法有没有指定的注解
        //5.获取到注解的value
        if (method.isAnnotationPresent(MyAnnotation.class)){
            System.out.println(method.getAnnotation(MyAnnotation.class).value());
        }
```

