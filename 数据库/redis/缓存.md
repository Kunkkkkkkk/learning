#### 缓存更新策略

1.内存淘汰：不维护，内存不足时自动淘汰部分数据

2.超时剔除：设置一个expire

3.主动更新：在更新数据库的同时更新redis数据库



对于那些高一致性的需求：比如显示详情这样的，店家更改了详情都得更新，不放心的话可以再加一个超时剔除兜底

---

![image-20240820190025939](缓存.assets/image-20240820190025939.png)

#### 主动更新

![image-20240820190201577](缓存.assets/image-20240820190201577.png)

1方法更可控，企业用这个方法的比较多。

有两种：1.更新缓存：即每一次更新数据库的时候更新缓存

​				2.删除缓存：每次更新数据库的时候直接把缓存删除，直到下一次查询的时候才会写入缓存。

一般更推荐用第二种，因为第一种如果一直修改不读，导致缓存的有效写入很少

---



所以先删缓存还是先操作数据库呢？

![image-20240820191218844](缓存.assets/image-20240820191218844.png)

右边最上面是刚好redis过期了，未命中缓存，所以右边的发生可能性更低

#### 缓存穿透

概念：就是传一个不存在的参数，然后依次访问缓存和数据库，有点像ddos攻击。

有两个方法

1. 缓存一个空对象，即未命中数据库也向缓存里面存一个空对象。

   ```
   优点：简单，维护方便
   缺点：因为存储到redis，对内存有额外的消耗，而且假如这个时候真的在数据库里插入了一个这个参数的对象，会导致缓存和数据库数据的短期不一致
   ```

   

2. 布隆过滤：有点像之前和你讲的那个位运算的01，也就是bool数组来判断，用复杂的算法，在传来参数的第一时间经过这个过滤器，如果存在就继续访问缓存，若不存在直接让他滚。

```
优点：不占用内存
缺点：还是有几率过滤出错，实现比较难
```

#### 缓存雪崩

![image-20240820202615716](缓存.assets/image-20240820202615716.png)

概念：同一时间内大量缓存同时失效了，或者redis服务器直接炸了，大量请求到达数据库

上面的解决方案解读：

1.没啥好说

2.redis高级里面说了，集群和主从，主服务器坏了用从服务器，而且主从有数据一致性，不用担心数据

3.在springcloud课程里有，比如快速失败拒绝服务

4.不仅在redis上缓存，还可以在浏览器，nginx等上添加缓存，那个未命中再请求redis再xxx这样。

#### 缓存击穿

概念：热点key