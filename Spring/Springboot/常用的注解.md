因为摒弃了xml文件配置的方式，`全注解驱动`

##### 1.组件注册

`Configuration` `@SpringBootConfiguration`告诉spring是一个配置类

配置类是 Spring 应用程序上下文中的一个中心配置点，【定义 Bean 和其他应用程序配置。】

@Bean只能用于方法

@Component可以直接在实体类里面让他变成一个组件

 `@Controller`

@`ComponentScan` `@Service`

通过注册组件，spring可以自动注入组件之间的依赖。可以简化对象的创建和管理。

@Autowired在Springboot前就有

作用

```
1.spring可以注入组件之间的依赖，比如接口和实现类
2.spring会管理组件的生命周期
3.依赖注入机制可以减少彼此之间的耦合，提高代码的可维护性和测试性。
第三点解释：
3.1减少耦合：实例化创建对象，以下面的例子来说，controller和service就耦合性高了。
3.2测试更方便：比如mock
  @Mock
    private GreetingService greetingService;

    @InjectMocks
    private GreetingController greetingController;
假如没有这个的话，就不能直接使用模拟对象来注入
```



```java
@Component：通用的组件注解，适用于任何Spring管理的组件。
@Service：用于标识服务层的组件。
@Repository：用于标识数据访问层的组件，通常与数据库交互。
@Controller：用于标识Web控制器，处理HTTP请求。
@RestController：特殊的控制器注解，相当于@Controller和@ResponseBody的组合，处理RESTful Web服务的请求。
```



###### 1.1ioc控制反转

传统对象是在对象内部自己控制，现在是一个ioc容器里放着一个个bean（组件或者对象）,通过容器来控制对象，控制权反转了。

例子

```java
不用ioc的
public class GreetingController {
    private GreetingService greetingService = new GreetingService();

    @GetMapping("/greet")
    public String greet() {
        return greetingService.greet();
    }
}
用ioc的
public class GreetingController {
  	@Autowired
    private GreetingService greetingService  //这里的GreetingService是接口
    @GetMapping("/greet")
    public String greet() {
        return greetingService.greet();
    }
}
```

这里就是Spring框架检查到@Autowired，直接把GreetingService的实现类的实例对象注入到greetingService上。



##### 2.条件注解

即如果这个条件成立，就触发行为

常见的

ConditionalOnXXXX

`ConditionalOnClass()`存在这个类就触发

`ConditionalMissClass()`不存在这个类就触发

`ConditonalOnBean()`

##### 3.属性绑定

```
@ConfigurationProperties(prefix = "cat")
@任何组件注册
```

 或者在要属性绑定的类只写 `@ConfigurationProperties(prefix = "cat")`,在启动类或者配置类上写一个

`EnableConfigrationProperties(Cat.class)`这个的意思就是自动注册组件